#include "can_buy.h"
#include "builder.h"
#include "guild.h"
#include "market.h"
#include "ressources.h"
#include "players.h"
#include "set.h"
#include "token.h"

#include <stdio.h>
#include <math.h>


// Used in find_max_eff_sub_market
void find_max_eff_sub_market_rec(
	struct market_t* base_market,
	struct market_t* best_market,
	struct market_t* market_to_cmp,
	struct set_t to_pay,
	int last_index_called,
	int max_use_token,
	int num_tokens
);


struct market_t find_max_eff_sub_market(struct market_t* base_market, struct set_t to_pay);


unsigned int is_usable(struct set_t *set, struct set_t cost)
{
	for (enum color_t j = 0 ; j < NUM_COLORS ; ++j)
	{
		if (cost.c[j] != 0 && set->c[j] != 0)  // Tests if the builder can helps with paying builder_to_buy
			return 1;
	}

	return 0;
}


/*
	Returns 1 if he can buy for a specific ressources generated by can_buy
*/
int can_buy(struct ressources_t* can_buy_out)
{
	for (int i = 0 ; i < can_buy_out->guild.n_builders ; ++i)
	{
		if (can_buy_out->guild.builders[i] != NULL)
			return 1;
	}

	for (int i = 0 ; i < NUM_TOKENS ; ++i)
	{
		if (can_buy_out->market.tokens[i] != NULL)
			return 1;
	}

	return 0;
}


struct builder_t * select_affordable_builder(struct guild_t* guild, struct player_t *player)
{
	struct builder_t *builder_wanted;
	struct set_t cost;

	for (unsigned int index = 0; index < MAX_BUILDERS ; ++index)
	{
		builder_wanted = available_builders_get_builder(guild, index); // Gets next builder available and check if it's possible to hire it
		if (builder_wanted != NULL)  // Tests if the player can buy it
		{
			cost = builder_requires(builder_wanted);
			struct ressources_t can_buy_ressources = is_buyable(cost, *player_get_ressources(player));	

			if (can_buy(&can_buy_ressources))
				return builder_wanted;
		}
	}

	return NULL;
}


/*
	Returns 1 if we can pay the set with the provided tokens (stock in the market)
*/
int can_use_market(struct set_t to_pay, struct market_t* market)
{
	struct token_t* token = NULL;
	struct set_t zero = set_zero();

	for (int index = 0 ; index < NUM_TOKENS ; ++index)
	{
		token = market->tokens[index];

		if (token != NULL)
		{
			// Reduce to_pay with the token
			for (enum color_t color = 0 ; color < NUM_COLORS ; ++color)
			{
				if (to_pay.c[color] > token->s.c[color])
					to_pay.c[color] = to_pay.c[color] - token->s.c[color];

				else
					to_pay.c[color] = 0;
			}

			/*
				Check if we can already buy it
			*/
			if (set_are_equals(&to_pay, &zero))
				return 1;
		}
	}

	return 0;
}


/*
 *  Returns the sum of the efficiency of every tokens of market to pay to_pay
 *
 *  Efficiency of a token: sum of ressources of the intersection of to_pay with the token
 *		then divided by the num of ressources of the token
 *
 *	Ex: eff of {1, 1, 2, 0, 0} to buy {1, 0, 1, 0, 0}
 *	 	-> returns (1 + 0 + 1 + 0 + 0) / 4 = 1/2
 *	   We only use half of the token to buy the set
 */
double eff(struct market_t market, struct set_t to_pay)
{
	double out = 0;  // Efficiency of market to buy to_pay
	struct set_t* tmp_set;  // Used to store current set in for
	struct set_t tmp_inter;  // Used to compute inter of tmp_set with to_pay

	for (int i = 0 ; i < NUM_TOKENS ; ++i)
	{
		if (market.tokens[i])
		{
			tmp_set = &market.tokens[i]->s;

			tmp_inter = set_inter(tmp_set, &to_pay);
			out += (double)(set_num_ressources(&tmp_inter)) / (double)(set_num_ressources(tmp_set));
		}
	}

	return out;
}


double dist_to_1(double x)
{
	return fabs(1 - x);
}


/*
 *  Returns 1 if eff(first_market) < eff(second_market)
 *
 *		 -1 if eff(second_market) < eff(first_market)
 *
 *		  0 if eff(first_market) = eff(second_market)
 */
int market_cmp(struct market_t first_market, struct market_t second_market, struct set_t to_pay)
{
	double first_eff = eff(first_market, to_pay);
	double second_eff = eff(second_market, to_pay);

	double first_dist = dist_to_1(first_eff);
	double second_dist = dist_to_1(second_eff);

	if (first_dist - second_dist < 0.005)  // Same eff, compare there number of tokens
	{
		int first_num_tokens = market_num_tokens(&first_market);
		int second_num_tokens = market_num_tokens(&second_market);

		if (first_num_tokens == second_num_tokens)
			return 0;

		if (first_num_tokens > second_num_tokens)
			return 1;

		return -1;
	}

	if (first_dist < second_dist)
		return 1;

	else if (first_dist > second_dist)
		return -1;

	return 0;
}


/*
 *  Returns first_market if it has better or equal efficiency to buy to_pay than second_market
 */
struct market_t get_best_market(struct market_t first_market, struct market_t second_market, struct set_t to_pay)
{
	if (market_cmp(first_market, second_market, to_pay) == 1)
		return second_market;

	return first_market;
}


struct ressources_t is_buyable(struct set_t cost, struct ressources_t ressources)
{
	struct ressources_t needed_ressources = {};

	struct guild_t* guild = &ressources.guild;
	struct market_t* market = &ressources.market;

	/*
		First, reduce the cost with the ressources provided by the builders
	*/
	// temporary variables
	struct set_t builder_provide;
	struct builder_t* builder;
	for (int index = 0 ; index < MAX_BUILDERS ; ++index)
	{
		builder = guild->builders[index];

		if (builder != NULL)
		{
			builder_provide = builder_provides(builder);

			for (enum color_t color = 0 ; color < NUM_COLORS ; ++color)
			{
				if (cost.c[color] > builder_provide.c[color])
				{
					cost.c[color] -= builder_provide.c[color];
				}

				else
				{
					cost.c[color] = 0;
				}
			}
		}
	}

	struct set_t left_to_pay = cost;

	/*
		Create an empty market (all the tokens at the start)
	*/
	struct market_t clean_market = create_default_market();
	
	for (int index = 0 ; index < NUM_TOKENS ; ++index)
	{
		if (market->tokens[index] != NULL)
		{
			market_pay_token(&clean_market, market->tokens[index]);
		}
	}

	struct market_t best_market = find_max_eff_sub_market(&clean_market, left_to_pay);

	if (market_num_tokens(&best_market) ==  0)  // Impossible to pay
	{
		struct ressources_t null_ressources = {};

		return null_ressources;
	}

	needed_ressources.market = best_market;

	return needed_ressources;
}


struct market_t find_max_eff_sub_market(struct market_t* base_market, struct set_t to_pay)
{
	struct market_t best_market = create_default_market();
	struct market_t empty_market = create_default_market();
	int num_ressources = set_num_ressources(&to_pay);	

	find_max_eff_sub_market_rec(base_market, &best_market, &empty_market, to_pay, -1, num_ressources, market_num_tokens(base_market));

	return best_market;
}



void find_max_eff_sub_market_rec(
	struct market_t* base_market,
	struct market_t* best_market,
	struct market_t* market_to_cmp,
	struct set_t to_pay,
	int last_index_called,
	int max_use_token,
	int num_tokens
	)
{
	int num_available_tokens = market_num_tokens(market_to_cmp);

	if (can_use_market(to_pay, market_to_cmp))
		*best_market = get_best_market(*market_to_cmp, *best_market, to_pay); 

	else if (num_available_tokens < max_use_token)
	{
		int start = last_index_called + 1;
		int upper_bound = num_tokens;

		for (int index = start ; index < upper_bound ; ++index)
		{
			struct market_t new_market_to_cmp = *market_to_cmp;
			market_pay_token(&new_market_to_cmp, base_market->tokens[index]);

			find_max_eff_sub_market_rec(base_market, best_market, &new_market_to_cmp, to_pay, index, max_use_token, num_tokens);
		}
	}
}

